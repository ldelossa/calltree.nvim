*calltree.txt* Calltree
*calltree.nvim*

Author:   Louis DeLosSantos <louis.delos@gmail.com>
Homepage: <https://github.com/ldelossa/calltree.nvim>
License:  MIT license

 ______   ________   __       __     _________  ______    ______   ______      
/_____/\ /_______/\ /_/\     /_/\   /________/\/_____/\  /_____/\ /_____/\     
\:::__\/ \::: _  \ \\:\ \    \:\ \  \__.::.__\/\:::_ \ \ \::::_\/_\::::_\/_    
 \:\ \  __\::(_)  \ \\:\ \    \:\ \    \::\ \   \:(_) ) )_\:\/___/\\:\/___/\   
  \:\ \/_/\\:: __  \ \\:\ \____\:\ \____\::\ \   \: __ `\ \\::___\/_\::___\/_  
   \:\_\ \ \\:.\ \  \ \\:\/___/\\:\/___/\\::\ \   \ \ `\ \ \\:\____/\\:\____/\ 
    \_____\/ \__\/\__\/ \_____\/ \_____\/ \__\/    \_\/ \_\/ \_____\/ \_____\/ 
                                                                               
====================================================================================
CONTENTS                                                         *calltree-contents*

  1. Intro........................................|calltree-intro|
  2. Usage........................................|caltree-usage|
  3. Commands.....................................|calltree-commands|
  4. Mappings.....................................|calltree-mappings|
  5. Config.......................................|calltree-config|
  6. Highlights...................................|calltree-highlights|

====================================================================================
INTRODUCTION                                                        *calltree-intro*

Calltree is a simple plugin which adds the missing "call-hierarchy" tool
found in IDEs such as Pycharm and VSCode. 

A "call-hierarchy" tool creates a tree view of incoming (callers) or outgoing
(callees) for a given symbol.

From there you can drive down further, discovering "callers-of-callers" or
"callees-of-callees", and producing a tree view.

Calltree also provides a document symbol tree.

====================================================================================
Usage                                                               *calltree-usage*

Calltree's entry point is the "calltree.lsp.handlers.ch_lsp_handler" function. 

This function returns a handler suitable for usage in neovim's LSP handler
table.

While the setup function will hijack the handlers table for you, you can also do this 
manually like so:

    vim.lsp.handlers['callHierarchy/incomingCalls'] = vim.lsp.with(
                require('calltree.lsp.handlers').ch_lsp_handler("from"), {}
    )
    vim.lsp.handlers['callHierarchy/outgoingCalls'] = vim.lsp.with(
                require('calltree.lsp.handlers').ch_lsp_handler("to"), {}
    )
    vim.lsp.handlers['textDocument/documentSymbol'] = vim.lsp.with(
                require('calltree.lsp.handlers').ws_lsp_handler(), {}
    )

This is what the "calltree.setup()" function does.

Once the calltree handlers are in place issuing the normal "vim.lsp.buf.incoming_calls" 
and "vim.lsp.buf.outgoing_calls" will open the calltree window.

The calltree UI can be used as a unified panel or as individual elements. 

A unified panel would feel similar to IDE's such as VSCode where you can "hide"
and "unhide" a persistent informational panel. Both the symbol tree and the call tree will
always be present in the toggled panel, unless you manually close a window. 
Toggling the panel will recreate any closed windows. This functionality
is provided via the "CTToggle" command.

If you'd rather use each individual component separately this is possible
too. Utilize the "CTOpen/CTClose" and "STOpen/STClose" commands. These commands
will only open and close the respective UI components.

By default performing a "call-hierarchy" request for incoming or outgoing calls
does not assume a unified panel. If you'd like it to open the unified panel on LSP requests
then set "unified_panel" to true in the config. See *calltree-config*

From there check out *calltree-commands* to manipulate the calltree UI.

====================================================================================
COMMANDS                                                         *calltree-commands*

Calltree exports several commands for manipulating the calltree UI. 

                                                                           *:CTOpen*
:CTOpen                                         
    Open the calltree window with the most recent call tree present. 

                                                                          *:CTClose*       
:CTClose       
    Closes the calltree window.
                                                                           *:STOpen*

                                                                         *:CTToggle*
:CTToggle
    Treats calltree as a persistent panel and toggles it open or close.
    Using this command will always toggle both the symboltree and calltree
    components as if they were a single unified panel.

:STOpen                                         
    Open the symboltree window with the most recent outline tree present. 

                                                                          *:STClose*       
:STClose       
    Closes the symboltree window

                                                                         *:CTExpand*
:CTExpand      
    Expands a calltree symbol resolving any callers/callees of the symbol under 
    the cursor.

                                                                       *:CTCollapse*    
:CTCollapse    
    Collapses a calltree symbol and its subtree.

                                                                          *:CTFocus*    
:CTFocus    
    Create a new calltree with the symbol under the cursor as root.

                                                                           *:CTJump*    
:CTJump        
    Jump to the symbol's definition. 
    How this jump is done is controlled via config.

                                                                         *:CTSwitch*    
:CTSwitch        
    Focus the symbol under the cursor and switch the calltree's
    direction.

    For example, if your currently viewing incoming calls for symbol
    Func1 and perform a CTSwtch, Func1 will become root and the calltree
    will show outgoing calls for this symbol.

    The typical use case is calling CTSwitch on the root symbol, turning
    the current outgoing calltree to an incoming call tree (or vice versa).
                                                                          
                                                                          *:CTHover* 
:CTHover       
    Show hover info for the symbol

                                                                         *CTDetails* 
:CTDetails      
    Show symbol detail information in a popup.

                                                                        *:CTClearHL* 
:CTClearHL       
    Clears any highlights after jumping to location.

    Highlights are also clearned when the current Calltree window
    is closed.

                                                                       *:CTDumpTree* 
:CTDumpTree       
    Echos the current calltree in lua dictonary syntax. 
    Useful for debugging.

====================================================================================
MAPPINGS                                                         *calltree-mappings*

Since all of calltree's usage happens within it's own buffer, 
its pretty safe to assign this buffer a default keymap. 

This does not stop you from mapping *calltree-commands* to your own liking.

The default buffer mapping is set via lua and should feel familiar if you use vim folds.

    vim.api.nvim_buf_set_keymap(buffer_handle, "n", "zo", ":CTExpand<CR>", opts)
    vim.api.nvim_buf_set_keymap(buffer_handle, "n", "zc", ":CTCollapse<CR>", opts)
    vim.api.nvim_buf_set_keymap(buffer_handle, "n", "<CR>", ":CTJump<CR>", opts)
    vim.api.nvim_buf_set_keymap(buffer_handle, "n", "f", ":CTFocus<CR>", opts)
    vim.api.nvim_buf_set_keymap(buffer_handle, "n", "i", ":CTHover<CR>", opts)
    vim.api.nvim_buf_set_keymap(buffer_handle, "n", "d", ":CTDetails<CR>", opts)
    vim.api.nvim_buf_set_keymap(buffer_handle, "n", "s", ":CTSwitch<CR>", opts)
    vim.api.nvim_buf_set_keymap(buffer_handle, "n", "?", ":lua require('calltree.ui').help(true)<CR>", opts)

====================================================================================
CONFIG                                                             *calltree-config*

To configure calltree you can pass a config table to "require('calltree').setup(config)".
You only need to specify the fields you wish to override.

The config table is described below:

    M.config = {
        -- where the calltree ui will spawn
        -- "left" (default) - Spawn calltree as the left most vertical window.
        -- "right"          - Spawn calltree as the left most vertical window.
        -- "top"            - Spawn calltree as the bottom most horizontal window
        --                    more details about the symbol will be shown with this
        --                    layout.
        -- "bottom"         - Spawn calltree as the top most horizontal window
        --                    more details about the symbol will be shown with this
        --                    layout.
        layout = "left",
        -- the initial size of the calltree ui
        -- int              - An integer used in the initial "resize" command for
        --                    the ui. 
        layout_size = 30,
        -- whether to automatically open the calltree and symboltree ui on start.
        auto_open = false,
        -- the method used when jumping to a symbol in the calltree 
        -- "invoking"       - Jumping to a symbol will use the window which the calltree
        --                    was initially invoked from.
        --                    If the invoking window has been removed a new botright split
        --                    will be created and take on the invoking window identity from there.
        -- "neighbor"       - Jumping to a symbol will use the neighbor on the opposite side of
        --                    the call tree. 
        --                    If no neighbor exists a split will be created for the jump. 
        jump_mode = "invoking",
        -- the icon to represent the symbol type
        -- "none"           - No icons for symbol types will just use text
        -- "nerd"           - Use Nerd font icon set for symbol types (requires patched font)
        -- "codicon"        - Use VSCode codicon icon set for symbol types (requires patched font)
        icons = "none",
        -- disables highlights in the calltree UI completely.
        no_hls = false,
        -- user provided icon highlight overrides. 
        -- see *calltree-icon-highlights*
        icon_highlights = {},
        -- bool which enables or diables indentation guides in the UI.
        -- defaults to true.
        indent_guides = true,
        -- user provided UI highlights.
        -- see *calltree-ui-highlights*
        hls = {}
        -- some LSP's will provide symbols with different names depending on
        -- the method called. 
        --
        -- if resolve_symbols is set to true a workspace symbol request will
        -- be made for any responses from LSP's, providing clearer information 
        -- for symbols in the calltree.
        --
        -- this will cause the UI to open slower, tho the symbol requests are 
        -- async so it will not block the editor.
        -- for full context see: 
        -- https://github.com/golang/go/issues/49690#issuecomment-975902067
        --
        -- set this to false for large codebases to speed up opening
        -- the calltree.
        resolve_symbols = true
        -- if set to true calling LSP functions which trigger calltree UI 
        -- will open the unified panel. see *calltree-usage* for details.
        unified_panel = false
        -- automatic highlighting and window position updates when 
        -- navigating the symboltree UI. Set to false to disable.
        auto_highlight = true
    }

====================================================================================
HIGHLIGHTS                                                     *calltree-highlights*

A default set of highlights will be applied as long as "no_hls=false" is provided 
in the config (this is the default setting). 

Flipping this settings to true will disable all highlights (accept for jumps).

The default set of highlights may not work for your color scheme, therefore its
possible to theme calltree further. 

The default higlights will stay in sync with "https://github.com/ldelossa/vimdark"

See *calltree-icon-highlights* and *calltree-ui-highlights* for more info.

                                                          *calltree-icon-highlights*
Each icon in the calltree UI can have its own highlight applied to it. 

By default the following highlight groups will be used for each icon type:

    M.icon_hls = {
        Folder = "CTNamespace",
        Reference = "CTParameterReference",
        Color = "CTType",
        Snippet = "CTType",
        Keyword = "CTType",
        Value = "CTType",
        Unit = "CTType",
        Text = "CTString",
        File = "CTURI",
        Module = "CTNamespace",
        Namespace = "CTNamespace",
        Package = "CTNamespace",
        Class = "CTType",
        Method = "CTMethod",
        Property = "CTMethod",
        Field = "CTField",
        Constructor = "CTConstructor",
        Enum = "CTType",
        Interface = "CTType",
        Function = "CTFunction",
        Variable = "CTConstant",
        Constant = "CTConstant",
        String = "CTString",
        Number = "CTNumber",
        Boolean = "CTBoolean",
        Array = "CTConstant",
        Object = "CTType",
        Key = "CTType",
        Struct = "CTType",
        Null = "CTType",
        EnumMember = "CTField",
        Struct = "CTType",
        Event = "CTType",
        Operator = "CTOperator",
        TypeParameter = "CTParameter",
    }

If you maintain your own colorscheme then feel free to add or link these highlight groups
accordingly. 

If you don't want to define these highlight groups yourself and have a set of highlight groups
you'd like to use instead you can provide them via calltree's setup function. 

Any provided highlight groups will be merged with the table above. 

For example:

    calltree.setup({
        icon_hls = {
            File = MyFileIconHL
        }
    })

Will highlight "File" icons in the calltree UI using "MyFileIconHL" and highlight all others with the
default "CT*" highlight group defined above.

Individuals who are using tree-sitter highlights across the board (you're using a tree-sitter color scheme) should provide this table to the setup function:

    M.icon_hls = {
        Folder = "TSNamespace",
        Reference = "TSParameterReference",
        Color = "TSType",
        Snippet = "TSType",
        Keyword = "TSType",
        Value = "TSType",
        Unit = "TSType",
        Text = "TSString",
        File = "TSURI",
        Module = "TSNamespace",
        Namespace = "TSNamespace",
        Package = "TSNamespace",
        Class = "TSType",
        Method = "TSMethod",
        Property = "TSMethod",
        Field = "TSField",
        Constructor = "TSConstructor",
        Enum = "TSType",
        Interface = "TSType",
        Function = "TSFunction",
        Variable = "TSConstant",
        Constant = "TSConstant",
        String = "TSString",
        Number = "TSNumber",
        Boolean = "TSBoolean",
        Array = "TSConstant",
        Object = "TSType",
        Key = "TSType",
        Struct = "TSType",
        Null = "TSType",
        EnumMember = "TSField",
        Struct = "TSType",
        Event = "TSType",
        Operator = "TSOperator",
        TypeParameter = "TSParameter",
    }

                                                            *calltree-ui-highlights* 

Other UI highlights are provided by the "calltree.hls" table.
 
M.hls = {
    -- highlight of the virtual text positioned next to the symbol name in the calltree UI.
    SymbolDetailHL        = "CTSymbolDetail",
    -- highlight of the symbol itself in the calltree UI, e.g. "Func1"
    SymbolHL            = "CTSymbol",
    -- the hight of the symbol being jumped to in it's source file.
    SymbolJumpHL        = "CTSymbolJump",
    -- the highlight of any references to the above symbol.
    SymbolJumpRefsHL    = "CTSymbolJumpRefs"
}

The usage is similar to the icon highlights but are specified by supplying a "hls" table within the config supplied to calltree's setup function.

List of all unique highlights:
    -- ui
    hi CTSymbol             
    hi CTSymbolDetail         
    hi CTSymbolJump         
    hi CTSymbolJumpRefs     
    -- icons
    hi CTParameterReference 
    hi CTURI                
    hi CTNamespace          
    hi CTMethod             
    hi CTField              
    hi CTConstructor        
    hi CTType               
    hi CTFunction           
    hi CTConstant           
    hi CTString             
    hi CTNumber             
    hi CTBoolean            
    hi CTConstant           
    hi CTOperator           
    hi CTParameter          
